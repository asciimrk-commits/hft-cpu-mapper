<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>HFT CPU Mapper v3.3</title>
    <style>
        :root {
            --bg: #0a0a0f;
            --panel: #0d0d15;
            --panel-border: #1a1a2e;
            --text: #c0c0c0;
            --text-dim: #666;
            --accent: #00d4ff;
            --accent-dim: #0066aa;
            
            --socket0: #00d4ff;
            --socket1: #ff6d00;
            --socket2: #4caf50;
            --socket3: #ff5722;
            --numa: #c586c0;
            --numa-net: #ffd700;
            --l3: #4ec9b0;
            
            /* Roles Colors */
            --role-os: #607d8b;
            --role-irq: #d500f9;
            --role-udp: #ff6d00;
            --role-robot: #ff4081; /* Standard Robot */
            --role-pool1: #ff2d55; /* Robot Pool 1 */
            --role-pool2: #d50000; /* Robot Pool 2 */
            --role-ar: #c2185b;
            --role-gateway: #107c10;
            --role-rf: #008080;
            --role-click: #ffcc00;
            --role-formula: #ffffff;
            --role-trash: #8a6d3b;
            --role-isolated: #7b1fa2; /* Purple for Isolated */
            
            --core-size: 38px;
            --sidebar-width: 260px;
        }
        
        * { box-sizing: border-box; margin: 0; padding: 0; }
        
        body {
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            background: var(--bg);
            color: var(--text);
            height: 100vh;
            overflow: hidden;
            display: flex;
        }
        
        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--panel);
            border-right: 1px solid var(--panel-border);
            display: flex;
            flex-direction: column;
            transition: margin-left 0.3s ease;
            position: relative;
            z-index: 100;
            height: 100vh;
            overflow: hidden;
            flex-shrink: 0;
        }
        
        .sidebar.collapsed {
            margin-left: calc(-1 * var(--sidebar-width));
        }
        
        .sidebar-toggle {
            position: fixed;
            left: var(--sidebar-width);
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 50px;
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-left: none;
            border-radius: 0 6px 6px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--accent);
            font-size: 12px;
            transition: all 0.3s ease;
            z-index: 200;
        }
        
        .sidebar.collapsed + .main .sidebar-toggle,
        .sidebar.collapsed ~ .sidebar-toggle {
            left: 0;
        }
        
        .sidebar-toggle:hover {
            background: #1a1a2e;
            color: #fff;
            width: 28px;
        }
        
        .sidebar-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }
        
        .section {
            margin-bottom: 15px;
        }
        
        .section-title {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            color: var(--accent);
            margin-bottom: 8px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--panel-border);
        }
        
        textarea {
            width: 100%;
            background: #050508;
            border: 1px solid var(--panel-border);
            color: #9cdcfe;
            padding: 8px;
            font-family: inherit;
            font-size: 10px;
            resize: vertical;
            min-height: 50px;
            max-height: 120px;
        }
        
        textarea:focus {
            outline: 1px solid var(--accent);
        }
        
        .btn {
            width: 100%;
            padding: 8px 12px;
            border: none;
            cursor: pointer;
            font-family: inherit;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
            margin-top: 6px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, var(--accent) 0%, var(--accent-dim) 100%);
            color: #000;
        }
        
        .btn-primary:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }
        
        .btn-secondary {
            background: #1a1a2e;
            color: var(--text);
            border: 1px solid var(--panel-border);
        }
        
        .btn-secondary:hover {
            background: #252540;
        }
        
        /* Core - Adaptive sizing based on total cores */
        .core {
            width: var(--core-size);
            height: var(--core-size);
            background: #151520;
            border: 2px solid #333;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
            color: #555;
            cursor: crosshair;
            position: relative;
            transition: all 0.1s;
            user-select: none;
            border-radius: 3px;
        }
        
        .core:hover {
            border-color: #fff;
            z-index: 10;
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255,255,255,0.4);
        }
        
        .core.has-role {
            color: #fff;
            text-shadow: 0 1px 3px rgba(0,0,0,0.9);
        }
        
        .core .load-bar {
            position: absolute;
            bottom: 2px;
            left: 2px;
            right: 2px;
            height: 4px;
            background: #0a0a0f;
            overflow: hidden;
            border-radius: 1px;
        }
        
        .core .load-fill {
            height: 100%;
            transition: width 0.3s;
        }
        
        .core .irq-dot {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 6px;
            height: 6px;
            background: var(--role-irq);
            border-radius: 50%;
            box-shadow: 0 0 6px var(--role-irq);
        }
        
        /* Adaptive core sizes */
        .blueprint.cores-small .core { --core-size: 32px; font-size: 10px; }
        .blueprint.cores-medium .core { --core-size: 40px; font-size: 12px; }
        .blueprint.cores-large .core { --core-size: 50px; font-size: 14px; }
        .blueprint.cores-xlarge .core { --core-size: 60px; font-size: 16px; }
        
        /* Palette */
        .palette {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 4px;
        }
        
        .palette-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 5px 8px;
            background: #111118;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
            transition: all 0.15s;
        }
        
        .palette-item:hover {
            background: #1a1a28;
            transform: translateX(2px);
        }
        
        .palette-item.active {
            border-color: var(--accent);
            background: rgba(0, 212, 255, 0.1);
        }
        
        .palette-swatch {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            flex-shrink: 0;
        }
        
        /* Output box */
        .output-box {
            background: #050508;
            border: 1px solid var(--panel-border);
            padding: 8px;
            font-size: 10px;
            color: #888;
            max-height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        
        /* Main Area */
        .main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* Tabs */
        .tabs {
            display: flex;
            background: var(--panel);
            border-bottom: 1px solid var(--panel-border);
            padding: 0 20px;
        }
        
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            font-size: 12px;
            color: var(--text-dim);
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .tab:hover {
            color: var(--text);
            background: rgba(255,255,255,0.02);
        }
        
        .tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }
        
        /* Header */
        .header {
            background: linear-gradient(180deg, #0d0d18 0%, var(--bg) 100%);
            padding: 15px 25px;
            border-bottom: 1px solid var(--panel-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .header-left h1 {
            font-size: 16px;
            font-weight: 400;
            color: #fff;
            letter-spacing: 2px;
        }
        
        .header-left h1 span {
            color: var(--accent);
        }
        
        .header-left .subtitle {
            font-size: 10px;
            color: var(--text-dim);
            margin-top: 2px;
        }
        
        .header-stats {
            display: flex;
            gap: 25px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            color: #fff;
        }
        
        .stat-value.highlight {
            color: var(--numa-net);
        }
        
        .stat-label {
            font-size: 9px;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        /* Canvas */
        .canvas {
            flex: 1;
            overflow: auto;
            padding: 20px;
            background: 
                radial-gradient(circle at 50% 50%, rgba(0,212,255,0.03) 0%, transparent 50%),
                linear-gradient(90deg, rgba(26,26,46,0.3) 1px, transparent 1px),
                linear-gradient(rgba(26,26,46,0.3) 1px, transparent 1px);
            background-size: 100% 100%, 20px 20px, 20px 20px;
        }
        
        .canvas-empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            font-size: 14px;
        }
        
        /* Blueprint Layout */
        .blueprint {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .sockets-row {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        /* Socket */
        .socket {
            background: rgba(10, 10, 15, 0.9);
            border: 2px solid var(--socket0);
            padding: 15px;
            position: relative;
        }
        
        .socket[data-socket="1"] { border-color: var(--socket1); }
        .socket[data-socket="2"] { border-color: var(--socket2); }
        .socket[data-socket="3"] { border-color: var(--socket3); }
        
        .socket-label {
            position: absolute;
            top: -11px;
            left: 15px;
            background: var(--bg);
            padding: 2px 12px;
            font-size: 11px;
            font-weight: 700;
            letter-spacing: 2px;
            color: var(--socket0);
        }
        
        .socket[data-socket="1"] .socket-label { color: var(--socket1); }
        .socket[data-socket="2"] .socket-label { color: var(--socket2); }
        .socket[data-socket="3"] .socket-label { color: var(--socket3); }
        
        .socket-content {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        /* NUMA */
        .numa {
            background: rgba(197, 134, 192, 0.03);
            border: 1px dashed var(--numa);
            padding: 12px;
            position: relative;
            flex: 1;
            min-width: 180px;
        }
        
        .numa.is-network {
            border: 2px solid var(--numa-net);
            background: rgba(255, 215, 0, 0.06);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.15);
        }
        
        .numa-label {
            position: absolute;
            top: -9px;
            left: 12px;
            background: var(--bg);
            padding: 1px 10px;
            font-size: 10px;
            font-weight: 600;
            color: var(--numa);
        }
        
        .numa.is-network .numa-label {
            color: var(--numa-net);
            background: #0a0a0f;
        }
        
        .network-badge {
            position: absolute;
            top: -9px;
            right: 12px;
            background: var(--numa-net);
            color: #000;
            padding: 2px 8px;
            font-size: 9px;
            font-weight: 700;
            letter-spacing: 0.5px;
        }
        
        /* L3 Cache */
        .l3 {
            background: rgba(78, 201, 176, 0.04);
            border: 1px dotted var(--l3);
            padding: 10px;
            margin-top: 10px;
            position: relative;
        }
        
        .l3-label {
            position: absolute;
            top: -7px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg);
            padding: 0 8px;
            font-size: 9px;
            color: var(--l3);
            white-space: nowrap;
        }
        
        .cores-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
            justify-content: center;
        }
        
        /* Compare Mode */
        .compare-container {
            display: flex;
            gap: 20px;
            padding: 20px;
            height: 100%;
        }
        
        .compare-panel {
            flex: 1;
            background: var(--panel);
            border: 1px solid var(--panel-border);
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .compare-header {
            padding: 12px 15px;
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid var(--panel-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .compare-title {
            font-size: 12px;
            font-weight: 600;
            color: var(--accent);
        }
        
        .compare-body {
            flex: 1;
            overflow: auto;
            padding: 15px;
        }
        
        .compare-drop-zone {
            border: 2px dashed var(--panel-border);
            border-radius: 8px;
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .compare-drop-zone:hover {
            border-color: var(--accent);
            background: rgba(0,212,255,0.05);
        }
        
        .compare-drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(0,212,255,0.1);
        }
        
        .drop-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }
        
        .drop-text {
            font-size: 12px;
            color: var(--text-dim);
        }
        
        /* Compare diff markers */
        .core.diff-added {
            box-shadow: 0 0 0 2px #4caf50, 0 0 8px rgba(76,175,80,0.5);
        }
        
        .core.diff-removed {
            box-shadow: 0 0 0 2px #f44336, 0 0 8px rgba(244,67,54,0.5);
        }
        
        .core.diff-changed {
            box-shadow: 0 0 0 2px #ffeb3b, 0 0 8px rgba(255,235,59,0.5);
        }
        
        /* Compare summary */
        .compare-summary {
            padding: 15px 20px;
            background: var(--panel);
            border-top: 1px solid var(--panel-border);
            display: flex;
            gap: 30px;
            justify-content: center;
        }
        
        .summary-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
        }
        
        .summary-dot {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        .summary-dot.added { background: #4caf50; }
        .summary-dot.removed { background: #f44336; }
        .summary-dot.changed { background: #ffeb3b; }
        
        /* Tooltip */
        #tooltip {
            position: fixed;
            display: none;
            background: rgba(13, 13, 21, 0.95);
            border: 1px solid var(--panel-border);
            padding: 10px 12px;
            border-radius: 4px;
            font-size: 11px;
            z-index: 1000;
            pointer-events: none;
            max-width: 250px;
            backdrop-filter: blur(8px);
        }
        
        .tooltip-header {
            font-weight: 700;
            color: #fff;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid var(--panel-border);
        }
        
        .tooltip-row {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 3px;
            color: #aaa;
        }
        
        .tooltip-swatch {
            width: 8px;
            height: 8px;
            border-radius: 2px;
        }
        
        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: var(--bg); }
        ::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #444; }
        
        /* Validation */
        .validation-box {
            background: #050508;
            border: 1px solid var(--panel-border);
            padding: 8px;
            font-size: 10px;
            max-height: 100px;
            overflow-y: auto;
        }
        
        .val-error { color: #f44336; }
        .val-warn { color: #ff9800; }
        .val-info { color: #2196f3; }
        .val-ok { color: #4caf50; }
        
        /* Inter-socket bus animation */
        @keyframes busFlow {
            0% { stroke-dashoffset: 20; }
            100% { stroke-dashoffset: 0; }
        }
        
        .bus-line {
            stroke-dasharray: 8, 4;
            animation: busFlow 0.8s linear infinite;
        }
    </style>
</head>
<body>

<div class="sidebar-toggle" id="sidebarToggle" onclick="toggleSidebar()" title="Toggle Sidebar (Hotkey: [)">
    <span id="toggleIcon">‚óÄ</span>
</div>

<div class="sidebar" id="sidebar">
    <div class="sidebar-content">
        <div class="section">
            <div class="section-title">1. Input Data</div>
            <textarea id="inputData" placeholder="Paste cpu-map.sh output here..."></textarea>
            <button class="btn btn-primary" onclick="render()">Build Map</button>
        </div>
        
        <div class="section">
            <div class="section-title">2. Paint Tools</div>
            <div class="palette" id="palette"></div>
            <div style="margin-top: 8px; font-size: 9px; color: var(--text-dim);">
                Click to paint ‚Ä¢ Ctrl+Click to erase
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">3. Config Output</div>
            <button class="btn btn-secondary" onclick="copyConfig()">üìã Copy Config</button>
            <div class="output-box" id="output">Waiting for data...</div>
        </div>
        
        <div class="section">
            <div class="section-title">4. OS Sizing</div>
            <div style="display: flex; gap: 10px; font-size: 10px; margin-bottom: 6px;">
                <div>OS Cores: <strong id="calc-cores">-</strong></div>
                <div>Load: <strong id="calc-load">-</strong></div>
            </div>
            <div style="display: flex; align-items: center; gap: 8px; font-size: 10px;">
                <span>Target:</span>
                <input type="number" id="calc-target" value="3" min="1" style="width: 50px; background: #111; border: 1px solid #333; color: #fff; padding: 4px; text-align: center;" onchange="calculateSizing()">
                <span id="calc-result" style="color: #4caf50;">-</span>
            </div>
        </div>
        
        <div class="section">
            <div class="section-title">5. Import / Export</div>
            <button class="btn btn-secondary" onclick="exportConfig()">üíæ Export JSON</button>
            <button class="btn btn-secondary" onclick="importConfig()">üìÇ Import JSON</button>
        </div>
        
        <div class="section">
            <div class="section-title">6. Validation</div>
            <button class="btn btn-secondary" onclick="validateConfig()">‚úì Validate</button>
            <div class="validation-box" id="validation-output">
                <span style="color: var(--text-dim);">Click Validate to check</span>
            </div>
        </div>
    </div>
</div>

<div class="main">
    <div class="tabs">
        <div class="tab active" data-tab="mapper" onclick="switchTab('mapper')">CPU Mapper</div>
        <div class="tab" data-tab="compare" onclick="switchTab('compare')">Compare Configs</div>
    </div>
    
    <div id="tab-mapper" class="tab-content" style="display: flex; flex-direction: column; flex: 1; overflow: hidden;">
        <div class="header" id="header" style="display: none;">
            <div class="header-left">
                <h1>HFT <span>CPU MAPPER</span></h1>
                <div class="subtitle" id="header-subtitle">Waiting for data...</div>
            </div>
            <div class="header-stats" id="header-stats"></div>
        </div>
        <div class="canvas" id="canvas">
            <div class="canvas-empty">‚Üê Paste cpu-map.sh output and click "Build Map"</div>
        </div>
    </div>
    
    <div id="tab-compare" class="tab-content" style="display: none; flex-direction: column; flex: 1; overflow: hidden;">
        <div class="compare-container">
            <div class="compare-panel">
                <div class="compare-header">
                    <div class="compare-title">OLD CONFIG</div>
                    <button class="btn btn-secondary" style="width: auto; margin: 0; padding: 4px 10px; font-size: 10px;" onclick="clearCompare('old')">Clear</button>
                </div>
                <div class="compare-body" id="compare-old-body">
                    <div class="compare-drop-zone" id="drop-old" onclick="loadCompareFile('old')">
                        <div class="drop-icon">üìÅ</div>
                        <div class="drop-text">Drop JSON or click to select<br><strong>Old configuration</strong></div>
                    </div>
                </div>
            </div>
            
            <div class="compare-panel">
                <div class="compare-header">
                    <div class="compare-title">NEW CONFIG</div>
                    <button class="btn btn-secondary" style="width: auto; margin: 0; padding: 4px 10px; font-size: 10px;" onclick="clearCompare('new')">Clear</button>
                </div>
                <div class="compare-body" id="compare-new-body">
                    <div class="compare-drop-zone" id="drop-new" onclick="loadCompareFile('new')">
                        <div class="drop-icon">üìÅ</div>
                        <div class="drop-text">Drop JSON or click to select<br><strong>New configuration</strong></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="compare-summary" id="compare-summary" style="display: none;">
            <div class="summary-item">
                <div class="summary-dot added"></div>
                <span>Added: <strong id="diff-added">0</strong></span>
            </div>
            <div class="summary-item">
                <div class="summary-dot removed"></div>
                <span>Removed: <strong id="diff-removed">0</strong></span>
            </div>
            <div class="summary-item">
                <div class="summary-dot changed"></div>
                <span>Changed: <strong id="diff-changed">0</strong></span>
            </div>
        </div>
    </div>
</div>

<div id="tooltip"></div>

<script>
// ==================== CONSTANTS ====================
const ROLES = [
    { id: 'sys_os',   name: 'System (OS)',   color: '#607d8b' },
    { id: 'net_irq',  name: 'IRQ (Net)',     color: '#d500f9' },
    { id: 'udp',      name: 'UDP',           color: '#ff6d00' },
    { id: 'robot',    name: 'Robot',         color: '#ff4081' },
    { id: 'pool1',    name: 'Robot Pool 1',  color: '#ff2d55' },
    { id: 'pool2',    name: 'Robot Pool 2',  color: '#d50000' },
    { id: 'ar',       name: 'AR',            color: '#c2185b' },
    { id: 'gateway',  name: 'Gateway',       color: '#107c10' },
    { id: 'rf',       name: 'RF (Remote)',   color: '#008080' },
    { id: 'click',    name: 'Clickhouse',    color: '#ffcc00' },
    { id: 'formula',  name: 'Formula',       color: '#ffffff' },
    { id: 'trash',    name: 'Trash',         color: '#8a6d3b' },
    // ADDED: Isolated role (Purple)
    { id: 'isolated', name: 'Isolated',      color: '#7b1fa2' }
];

const ROLE_KEY_MAP = {
    'AllRobotsThCPU': 'ar',
    'ClickHouseCores': 'click',
    'Formula': 'formula',
    'GatewaysDefault': 'gateway',
    'RemoteFormulaCPU': 'rf',
    'RobotsDefault': 'robot',
    'TrashCPU': 'trash',
    'UdpReceiveCores': 'udp',
    'UdpSendCores': 'udp',
    'RobotsNode1': 'pool1',
    'RobotsNode2': 'pool2',
    // ADDED: Map dictionary 'Isolated' key to visual role
    'Isolated': 'isolated'
};

const ROLES_BY_ID = {};
ROLES.forEach(r => ROLES_BY_ID[r.id] = r);

// Priority list for display (Higher number = overrides lower)
// 'isolated' is lowest priority, so if any other tag exists, isolated is hidden
const ROLE_PRIORITY = {
    'sys_os': 100,
    'net_irq': 100,
    'pool1': 90,
    'pool2': 90,
    'robot': 90,
    'gateway': 80,
    'udp': 70,
    'ar': 60,
    'rf': 50,
    'click': 40,
    'formula': 30,
    'trash': 20,
    'isolated': 1 // Lowest priority
};

// ==================== STATE ====================
let activeTool = ROLES[3]; // Robot by default
let globalGeometry = {};
let coreNumaMap = {};
let netNumaNodes = new Set();
let serverName = '';
let instances = {};
let cpuLoadMap = {};
let isolatedCores = new Set();
let coreIRQMap = {};
let networkInterfaces = [];
let isMouseDown = false;

// Compare state
let compareOld = null;
let compareNew = null;

// ==================== INIT ====================
document.addEventListener('DOMContentLoaded', () => {
    initPalette();
    initDragDrop();
    document.addEventListener('mouseup', () => isMouseDown = false);
    document.addEventListener('keydown', (e) => {
        if (e.key === '[') toggleSidebar();
    });
});

function initPalette() {
    const container = document.getElementById('palette');
    container.innerHTML = ''; 
    ROLES.forEach(r => {
        const el = document.createElement('div');
        el.className = 'palette-item' + (r.id === activeTool.id ? ' active' : '');
        el.innerHTML = `<div class="palette-swatch" style="background:${r.color}"></div><span>${r.name}</span>`;
        el.onclick = () => {
            activeTool = r;
            document.querySelectorAll('.palette-item').forEach(x => x.classList.remove('active'));
            el.classList.add('active');
        };
        container.appendChild(el);
    });
}

function initDragDrop() {
    ['drop-old', 'drop-new'].forEach(id => {
        const el = document.getElementById(id);
        el.addEventListener('dragover', (e) => {
            e.preventDefault();
            el.classList.add('dragover');
        });
        el.addEventListener('dragleave', () => el.classList.remove('dragover'));
        el.addEventListener('drop', (e) => {
            e.preventDefault();
            el.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file && file.name.endsWith('.json')) {
                const target = id === 'drop-old' ? 'old' : 'new';
                readCompareFile(file, target);
            }
        });
    });
}

// ==================== SIDEBAR ====================
function toggleSidebar() {
    const sidebar = document.getElementById('sidebar');
    const icon = document.getElementById('toggleIcon');
    const toggle = document.getElementById('sidebarToggle');
    
    sidebar.classList.toggle('collapsed');
    const isCollapsed = sidebar.classList.contains('collapsed');
    
    icon.textContent = isCollapsed ? '‚ñ∂' : '‚óÄ';
    toggle.style.left = isCollapsed ? '0' : 'var(--sidebar-width)';
}

// ==================== TABS ====================
function switchTab(tab) {
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    document.querySelector(`.tab[data-tab="${tab}"]`).classList.add('active');
    
    document.querySelectorAll('.tab-content').forEach(c => c.style.display = 'none');
    document.getElementById(`tab-${tab}`).style.display = 'flex';
}

// ==================== PARSING ====================
function parseRangeStr(str) {
    const res = new Set();
    str.split(',').forEach(p => {
        p = p.trim();
        if (p.includes('-')) {
            const [start, end] = p.split('-').map(x => parseInt(x));
            for (let i = start; i <= end; i++) res.add(i);
        } else {
            const val = parseInt(p);
            if (!isNaN(val)) res.add(val);
        }
    });
    return Array.from(res);
}

function addTag(instanceName, cpu, tag) {
    if (!cpu) return;
    if (!instances[instanceName]) instances[instanceName] = {};
    if (!instances[instanceName][cpu]) instances[instanceName][cpu] = new Set();
    instances[instanceName][cpu].add(tag);
}

function parse(text) {
    globalGeometry = {};
    coreNumaMap = {};
    netNumaNodes = new Set();
    serverName = '';
    instances = { 'Physical': {} };
    cpuLoadMap = {};
    isolatedCores = new Set();
    coreIRQMap = {};
    networkInterfaces = [];

    const lines = text.split('\n');
    let mode = 'none';
    let currentInstance = null;
    let currentInterface = null;
    let parsingNetworkCpus = false;

    for (let line of lines) {
        line = line.trim();
        if (!line) continue;

        if (line.startsWith('=== –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫')) {
            const parts = line.split(' ');
            if (parts.length >= 4) serverName = parts[3].replace('.qb.loc', '');
        }

        if (line.includes('>>> 1. LSCPU')) { mode = 'lscpu'; continue; }
        if (line.includes('>>> 2. NUMA TOPOLOGY')) { mode = 'numatopo'; continue; }
        if (line.includes('>>> 3. ISOLATED CORES')) { mode = 'isolated'; continue; }
        if (line.includes('>>> 4. NETWORK')) { mode = 'network'; continue; }
        if (line.includes('>>> 5. RUNTIME CONFIG')) { mode = 'runtime'; continue; }
        if (line.includes('>>> 6. TOP INTERRUPTS')) { mode = 'interrupts'; continue; }
        if (line.includes('>>> 7. CPU LOAD')) { mode = 'cpuload'; continue; }

        if (mode === 'lscpu') {
            if (line.startsWith('CPU') || line.startsWith('#')) continue;
            const parts = line.split(',');
            if (parts.length < 6) continue;
            
            const cpu = parts[0].trim();
            const node = parts[1].trim();
            const socket = parts[2].trim();
            const cacheStr = parts[4].trim();
            
            let online, l3id;
            if (parts.length >= 10) {
                l3id = parts[8].trim() || 'U';
                online = parts[9].trim();
            } else {
                online = parts[5].trim();
                l3id = 'U';
                if (cacheStr.includes(':')) {
                    const cParts = cacheStr.split(':');
                    if (cParts.length >= 4) l3id = cParts[3];
                }
            }
            
            if (online === 'no' || node === '-' || socket === '-') continue;

            coreNumaMap[cpu] = node;
            if (!globalGeometry[socket]) globalGeometry[socket] = {};
            if (!globalGeometry[socket][node]) globalGeometry[socket][node] = {};
            if (!globalGeometry[socket][node][l3id]) globalGeometry[socket][node][l3id] = [];
            globalGeometry[socket][node][l3id].push(cpu);
            
            if (parseInt(cpu) === 0) addTag('Physical', cpu, 'sys_os');
        }

        if (mode === 'isolated') {
            if (line !== 'none' && line.length > 0) {
                parseRangeStr(line).forEach(c => isolatedCores.add(c.toString()));
            }
        }

        if (mode === 'network') {
            if (line.startsWith('Interface:')) {
                const ifaceMatch = line.match(/Interface:\s*(\S+)/);
                if (ifaceMatch) {
                    currentInterface = { name: ifaceMatch[1], numaNode: null, irqs: [] };
                    networkInterfaces.push(currentInterface);
                }
            }
            
            if (currentInterface && line.startsWith('NUMA Node:')) {
                const numaMatch = line.match(/NUMA Node:\s*(-?\d+)/);
                if (numaMatch) {
                    currentInterface.numaNode = numaMatch[1];
                    if (numaMatch[1] !== '-1') netNumaNodes.add(numaMatch[1]);
                }
            }
            
            if (currentInterface) {
                const irqMatch = line.match(/^\s*IRQ\s+(\d+):\s*([\d,\s-]+)/);
                if (irqMatch) {
                    const irqNum = irqMatch[1];
                    const cores = parseRangeStr(irqMatch[2]);
                    currentInterface.irqs.push({ irq: irqNum, cpus: cores });
                    cores.forEach(c => {
                        const cStr = c.toString();
                        addTag('Physical', cStr, 'net_irq');
                        if (!coreIRQMap[cStr]) coreIRQMap[cStr] = [];
                        coreIRQMap[cStr].push(irqNum);
                    });
                }
            }
        }

        if (mode === 'runtime') {
            const instanceMatch = line.match(/^(\w+):$/);
            if (instanceMatch) {
                const name = instanceMatch[1];
                if (name !== 'Overview' && name !== 'Instance' && name !== 'Cpus') {
                    currentInstance = name;
                    if (!instances[currentInstance]) instances[currentInstance] = {};
                } else {
                    currentInstance = 'Physical';
                }
            }

            const cpuDictMatch = line.match(/'cpu_id':\s*(\d+)/);
            if (cpuDictMatch) {
                const cpuId = cpuDictMatch[1];
                if (line.includes("'net_cpu':")) {
                    addTag('Physical', cpuId, 'net_irq');
                    const n = coreNumaMap[cpuId];
                    if (n !== undefined) netNumaNodes.add(n.toString());
                }
                if (line.includes("'isolated': True")) isolatedCores.add(cpuId);
                
                Object.keys(ROLE_KEY_MAP).forEach(key => {
                    const pattern = new RegExp(`['"]?${key}['"]?:\\s*\\[([^\\]]+)\\]`);
                    const match = line.match(pattern);
                    if (match) {
                        const instNames = match[1].split(',').map(s => s.trim().replace(/['"]/g, ''));
                        instNames.forEach(instName => {
                            if (!instances[instName]) instances[instName] = {};
                            addTag(instName, cpuId, ROLE_KEY_MAP[key]);
                        });
                    }
                });
            }

            if (line.startsWith('System cpus:')) {
                parseRangeStr(line.replace('System cpus:', '')).forEach(c => addTag('Physical', c.toString(), 'sys_os'));
            }

            if (line.includes('topology information')) {
                parsingNetworkCpus = false;
            }
            if (line.startsWith('Network interfaces cpus:')) {
                parsingNetworkCpus = true;
            }
            
            if (parsingNetworkCpus && line.match(/^(net\d+|eni\d+|eth\d+|ens\d+|enp\d+):\s*([\d,\s-]+)$/)) {
                const netMatch = line.match(/^([^:]+):\s*([\d,\s-]+)$/);
                if (netMatch) {
                    const cores = parseRangeStr(netMatch[2]);
                    cores.forEach(c => addTag('Physical', c.toString(), 'net_irq'));
                    if (cores.length > 0) {
                        cores.forEach(c => {
                            const n = coreNumaMap[c.toString()];
                            if (n !== undefined) netNumaNodes.add(n.toString());
                        });
                    }
                }
            }
        }

        if (mode === 'cpuload') {
            if (line.includes('CPU') || line.includes('all') || line.includes('Average')) continue;
            const match = line.match(/(?:AM|PM)?\s*(\d+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)\s+([\d.]+)$/);
            if (match) {
                cpuLoadMap[match[1]] = (100 - parseFloat(match[11])).toFixed(1);
            }
        }
    }
    return globalGeometry;
}

// ==================== RENDERING ====================
function render() {
    const txt = document.getElementById('inputData').value;
    const geom = parse(txt);
    const canvas = document.getElementById('canvas');
    
    if (Object.keys(geom).length === 0) {
        canvas.innerHTML = '<div class="canvas-empty">No CPU data found</div>';
        return;
    }

    updateHeader();
    
    const totalCores = Object.keys(coreNumaMap).length;
    let sizeClass = 'cores-large';
    if (totalCores > 128) sizeClass = 'cores-small';
    else if (totalCores > 64) sizeClass = 'cores-medium';
    else if (totalCores <= 24) sizeClass = 'cores-xlarge';
    
    let html = `<div class="blueprint ${sizeClass}">`;
    
    const sockets = Object.keys(geom).sort((a, b) => a - b);
    for (let i = 0; i < sockets.length; i += 2) {
        html += '<div class="sockets-row">';
        for (let j = i; j < Math.min(i + 2, sockets.length); j++) {
            html += renderSocket(sockets[j], geom[sockets[j]]);
        }
        html += '</div>';
    }
    
    html += '</div>';
    canvas.innerHTML = html;
    
    Object.keys(coreNumaMap).forEach(cpu => updateCoreVisual('Physical', cpu));
    
    updateStats();
    calculateSizing();
}

function renderSocket(socketId, numaData) {
    let html = `<div class="socket" data-socket="${socketId}">`;
    html += `<div class="socket-label">SOCKET ${socketId}</div>`;
    html += '<div class="socket-content">';
    
    Object.keys(numaData).sort((a, b) => a - b).forEach(numaId => {
        const isNetwork = netNumaNodes.has(numaId);
        html += `<div class="numa ${isNetwork ? 'is-network' : ''}" data-numa="${numaId}">`;
        html += `<div class="numa-label">NUMA ${numaId}</div>`;
        if (isNetwork) html += '<div class="network-badge">NET</div>';
        
        Object.keys(numaData[numaId]).sort((a, b) => parseInt(a) - parseInt(b)).forEach(l3Id => {
            html += `<div class="l3">`;
            html += `<div class="l3-label">L3 #${l3Id}</div>`;
            html += '<div class="cores-grid">';
            
            numaData[numaId][l3Id].forEach(cpu => {
                html += renderCore('Physical', cpu);
            });
            
            html += '</div></div>';
        });
        
        html += '</div>';
    });
    
    html += '</div></div>';
    return html;
}

function renderCore(instanceName, cpu) {
    const load = parseFloat(cpuLoadMap[cpu] || 0);
    let loadColor = '#4caf50';
    if (load > 50) loadColor = '#ffeb3b';
    if (load > 80) loadColor = '#f44336';
    
    const hasIRQ = coreIRQMap[cpu] && coreIRQMap[cpu].length > 0;
    
    return `
        <div class="core" id="core-${instanceName}-${cpu}" data-cpu="${cpu}"
             onmousedown="onCoreMouseDown(event, '${instanceName}', '${cpu}')"
             onmouseenter="onCoreMouseEnter(event, '${instanceName}', '${cpu}')"
             onmousemove="moveTooltip(event)"
             onmouseleave="hideTooltip()">
            ${cpu}
            <div class="load-bar"><div class="load-fill" style="width:${load}%;background:${loadColor}"></div></div>
            ${hasIRQ ? '<div class="irq-dot"></div>' : ''}
        </div>
    `;
}

// HELPER: Get effective tags by priority
// If specific tags exist (gateway, robot), hide 'isolated'
function getDisplayTags(instanceName, cpu) {
    let allTags = new Set();
    
    // Add Physical layer tags
    if (instances['Physical']?.[cpu]) {
        instances['Physical'][cpu].forEach(t => allTags.add(t));
    }
    
    // Add tags from all other instances
    Object.keys(instances).forEach(instName => {
        if (instName !== 'Physical' && instances[instName]?.[cpu]) {
            instances[instName][cpu].forEach(t => allTags.add(t));
        }
    });

    // Check if we have high priority tags
    let hasHighPriority = false;
    for (let t of allTags) {
        if ((ROLE_PRIORITY[t] || 0) > ROLE_PRIORITY['isolated']) {
            hasHighPriority = true;
            break;
        }
    }

    // Filter tags logic
    const displayTags = [];
    allTags.forEach(t => {
        // If we have high priority tags, skip 'isolated'
        if (t === 'isolated' && hasHighPriority) return;
        displayTags.push(t);
    });

    // Sort by priority descending
    displayTags.sort((a, b) => (ROLE_PRIORITY[b] || 0) - (ROLE_PRIORITY[a] || 0));
    
    return displayTags;
}

function updateCoreVisual(instanceName, cpu) {
    const el = document.getElementById(`core-${instanceName}-${cpu}`);
    if (!el) return;
    
    const displayTags = getDisplayTags(instanceName, cpu);
    
    el.classList.remove('has-role', 'diff-added', 'diff-removed', 'diff-changed');
    el.style.background = '';
    el.style.borderColor = '';
    
    if (displayTags.length > 0) {
        el.classList.add('has-role');
        const primaryRole = ROLES_BY_ID[displayTags[0]];
        
        if (primaryRole) {
            el.style.background = primaryRole.color;
            el.style.borderColor = primaryRole.color;
        }
        
        if (displayTags.length > 1) {
            const colors = displayTags.map(t => ROLES_BY_ID[t]?.color || '#fff');
            const gradient = colors.map((c, i) => `${c} ${(i/colors.length)*100}%, ${c} ${((i+1)/colors.length)*100}%`).join(',');
            el.style.background = `linear-gradient(135deg, ${gradient})`;
            el.style.borderColor = '#fff';
        }
    }
}

function updateHeader() {
    document.getElementById('header').style.display = 'flex';
    document.getElementById('header-subtitle').textContent = serverName ? 
        `${serverName}.qb.loc | ${new Date().toLocaleString()}` : 'Ready';
    
    const allCores = Object.keys(coreNumaMap);
    const usedCores = Object.keys(instances['Physical'] || {}).filter(cpu => 
        instances['Physical'][cpu]?.size > 0
    ).length;
    
    let totalLoad = 0, loadCount = 0;
    allCores.forEach(cpu => {
        const load = parseFloat(cpuLoadMap[cpu] || 0);
        if (load > 0) { totalLoad += load; loadCount++; }
    });
    
    const statsHtml = `
        <div class="stat"><div class="stat-value">${allCores.length}</div><div class="stat-label">Total</div></div>
        <div class="stat"><div class="stat-value">${usedCores}</div><div class="stat-label">Used</div></div>
        <div class="stat"><div class="stat-value">${allCores.length - usedCores}</div><div class="stat-label">Free</div></div>
        <div class="stat"><div class="stat-value highlight">${netNumaNodes.size > 0 ? [...netNumaNodes].join(',') : 'N/A'}</div><div class="stat-label">Net NUMA</div></div>
        <div class="stat"><div class="stat-value">${loadCount > 0 ? (totalLoad/loadCount).toFixed(0) + '%' : '-'}</div><div class="stat-label">Avg Load</div></div>
    `;
    document.getElementById('header-stats').innerHTML = statsHtml;
}

// ==================== INTERACTIONS ====================
function onCoreMouseDown(e, instanceName, cpu) {
    isMouseDown = true;
    const isEraser = e.ctrlKey || e.metaKey;
    applyTool(instanceName, cpu, false, isEraser);
}

function onCoreMouseEnter(e, instanceName, cpu) {
    if (isMouseDown) {
        const isEraser = e.ctrlKey || e.metaKey;
        applyTool(instanceName, cpu, true, isEraser);
    }
    showTooltip(e, instanceName, cpu);
}

function applyTool(instanceName, cpu, forceAdd, isEraser) {
    if (!instances[instanceName]) instances[instanceName] = {};
    if (!instances[instanceName][cpu]) instances[instanceName][cpu] = new Set();
    
    if (isEraser) {
        instances[instanceName][cpu].clear();
    } else {
        if (instances[instanceName][cpu].has(activeTool.id) && !forceAdd) {
            instances[instanceName][cpu].delete(activeTool.id);
        } else {
            instances[instanceName][cpu].add(activeTool.id);
        }
    }
    
    updateCoreVisual(instanceName, cpu);
    updateStats();
    calculateSizing();
}

// ==================== TOOLTIP ====================
function showTooltip(e, instanceName, cpu) {
    const tooltip = document.getElementById('tooltip');
    
    // Use the filtered display tags for the tooltip too
    const tags = getDisplayTags(instanceName, cpu);
    const load = cpuLoadMap[cpu];
    
    let html = `<div class="tooltip-header">Core ${cpu}</div>`;
    
    if (load !== undefined) {
        let color = '#4caf50';
        if (load > 50) color = '#ffeb3b';
        if (load > 80) color = '#f44336';
        html += `<div style="color:${color};font-weight:bold;margin-bottom:4px;">Load: ${load}%</div>`;
    }
    
    if (coreIRQMap[cpu]?.length > 0) {
        html += `<div style="color:#d500f9;font-size:10px;">IRQ: ${coreIRQMap[cpu].join(', ')}</div>`;
    }
    
    if (tags.length > 0) {
        html += '<div style="margin-top:4px;">';
        tags.forEach(tid => {
            const r = ROLES_BY_ID[tid];
            if (r) html += `<div class="tooltip-row"><div class="tooltip-swatch" style="background:${r.color}"></div>${r.name}</div>`;
        });
        html += '</div>';
    }
    
    tooltip.innerHTML = html;
    tooltip.style.display = 'block';
    moveTooltip(e);
}

function moveTooltip(e) {
    const tooltip = document.getElementById('tooltip');
    tooltip.style.top = (e.clientY + 15) + 'px';
    tooltip.style.left = (e.clientX + 15) + 'px';
}

function hideTooltip() {
    document.getElementById('tooltip').style.display = 'none';
}

// ==================== CONFIG OUTPUT ====================
function updateStats() {
    let txt = serverName ? `# ${serverName}\n` : '';
    
    const instKeys = Object.keys(instances).filter(k => k !== 'Physical').sort();
    
    // Physical layer - only OS and IRQ
    if (instances['Physical']) {
        txt += '\n### Physical ###\n';
        const roles = {};
        for (const [cpu, tags] of Object.entries(instances['Physical'])) {
            tags.forEach(t => {
                if (t === 'sys_os' || t === 'net_irq') {
                    if (!roles[t]) roles[t] = [];
                    roles[t].push(parseInt(cpu));
                }
            });
        }
        if (roles['sys_os']) txt += `System: [${roles['sys_os'].sort((a,b)=>a-b).join(', ')}]\n`;
        if (roles['net_irq']) txt += `IRQ:    [${roles['net_irq'].sort((a,b)=>a-b).join(', ')}]\n`;
    }

    // Instance-specific roles
    instKeys.forEach(inst => {
        txt += `\n### ${inst} ###\n`;
        const roleCores = {};
        const data = instances[inst];
        
        for (const [cpu, tags] of Object.entries(data)) {
            tags.forEach(t => {
                // IMPORTANT: Filter isolated here too if needed, but usually config export keeps raw data
                if (!roleCores[t]) roleCores[t] = [];
                roleCores[t].push(parseInt(cpu));
            });
        }
        
        ROLES.forEach(role => {
            if (roleCores[role.id]?.length > 0) {
                txt += `${role.name}: [${roleCores[role.id].sort((a,b)=>a-b).join(', ')}]\n`;
            }
        });
    });

    document.getElementById('output').textContent = txt;
}

function copyConfig() {
    navigator.clipboard.writeText(document.getElementById('output').textContent).then(() => {
        const btn = event.target;
        const orig = btn.textContent;
        btn.textContent = '‚úì Copied!';
        setTimeout(() => btn.textContent = orig, 1000);
    });
}

// ==================== SIZING CALCULATOR ====================
function calculateSizing() {
    const phys = instances['Physical'];
    if (!phys) return;
    
    const sysCores = Object.entries(phys).filter(([cpu, tags]) => tags.has('sys_os')).map(([cpu]) => cpu);
    let totalLoad = 0;
    sysCores.forEach(c => totalLoad += parseFloat(cpuLoadMap[c] || 0));
    
    document.getElementById('calc-cores').textContent = sysCores.length;
    document.getElementById('calc-load').textContent = Math.round(totalLoad) + '%';
    
    const target = parseInt(document.getElementById('calc-target').value) || 1;
    const avgLoad = target > 0 ? totalLoad / target : 0;
    
    let status = 'OK', color = '#4caf50';
    if (avgLoad >= 50) { status = 'WARN'; color = '#ff9800'; }
    if (avgLoad >= 80) { status = 'CRIT'; color = '#f44336'; }
    
    document.getElementById('calc-result').innerHTML = `<span style="color:${color}">${Math.round(avgLoad)}% (${status})</span>`;
}

// ==================== IMPORT / EXPORT ====================
function exportConfig() {
    const config = {
        version: "3.3",
        serverName: serverName,
        timestamp: new Date().toISOString(),
        geometry: globalGeometry,
        netNumaNodes: [...netNumaNodes],
        instances: {}
    };
    
    Object.keys(instances).forEach(instName => {
        config.instances[instName] = {};
        Object.keys(instances[instName]).forEach(cpu => {
            config.instances[instName][cpu] = [...instances[instName][cpu]];
        });
    });
    
    const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = `cpu-config-${serverName || 'unknown'}-${new Date().toISOString().split('T')[0]}.json`;
    a.click();
}

function importConfig() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) {
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const config = JSON.parse(ev.target.result);
                    applyConfig(config);
                    render();
                    alert('Config imported!');
                } catch (err) {
                    alert('Error: ' + err.message);
                }
            };
            reader.readAsText(file);
        }
    };
    input.click();
}

function applyConfig(config) {
    if (config.serverName) serverName = config.serverName;
    if (config.geometry) globalGeometry = config.geometry;
    if (config.netNumaNodes) netNumaNodes = new Set(config.netNumaNodes);
    
    instances = {};
    Object.keys(config.instances).forEach(instName => {
        instances[instName] = {};
        Object.keys(config.instances[instName]).forEach(cpu => {
            instances[instName][cpu] = new Set(config.instances[instName][cpu]);
        });
    });
    
    coreNumaMap = {};
    Object.keys(globalGeometry).forEach(socket => {
        Object.keys(globalGeometry[socket]).forEach(numa => {
            Object.keys(globalGeometry[socket][numa]).forEach(l3 => {
                globalGeometry[socket][numa][l3].forEach(cpu => {
                    coreNumaMap[cpu] = numa;
                });
            });
        });
    });
}

// ==================== VALIDATION ====================
function validateConfig() {
    const errors = [], warnings = [], info = [];
    const DEDICATED = ['gateway', 'robot', 'pool1', 'pool2', 'net_irq'];
    const NET_REQUIRED = ['gateway', 'net_irq'];
    const netNodes = [...netNumaNodes];
    
    Object.keys(instances).forEach(instName => {
        const inst = instances[instName];
        Object.keys(inst).forEach(cpu => {
            const tags = inst[cpu];
            if (!tags || tags.size === 0) return;
            
            const tagsArr = [...tags];
            const load = parseFloat(cpuLoadMap[cpu] || 0);
            const numa = coreNumaMap[cpu]?.toString();
            
            DEDICATED.forEach(role => {
                if (tags.has(role) && tags.size > 1) {
                    // Check if the other tags are just 'isolated', which is allowed
                    const meaningfulTags = tagsArr.filter(t => t !== 'isolated');
                    if (meaningfulTags.length > 1 && meaningfulTags.includes(role)) {
                         const others = meaningfulTags.filter(t => t !== role).map(t => ROLES_BY_ID[t]?.name || t).join(', ');
                         errors.push(`[${instName}] CPU ${cpu}: ${ROLES_BY_ID[role]?.name} needs dedicated core, shares with: ${others}`);
                    }
                }
            });
            
            if (netNodes.length > 0 && numa) {
                NET_REQUIRED.forEach(role => {
                    if (tags.has(role) && !netNodes.includes(numa)) {
                        errors.push(`[${instName}] CPU ${cpu}: ${ROLES_BY_ID[role]?.name} must be on network NUMA (current: ${numa}, net: ${netNodes.join(',')})`);
                    }
                });
            }
            
            if ((tags.has('gateway') || tags.has('robot') || tags.has('pool1') || tags.has('pool2')) && load > 80) {
                errors.push(`[${instName}] CPU ${cpu}: Critical service overloaded (${load}%)`);
            } else if ((tags.has('gateway') || tags.has('robot') || tags.has('pool1') || tags.has('pool2')) && load > 50) {
                warnings.push(`[${instName}] CPU ${cpu}: High load on critical service (${load}%)`);
            }
        });
    });
    
    const phys = instances['Physical'];
    if (phys) {
        const osCores = Object.keys(phys).filter(cpu => phys[cpu].has('sys_os'));
        if (osCores.length === 0) {
            warnings.push('No OS cores allocated');
        } else {
            let osLoad = 0;
            osCores.forEach(c => osLoad += parseFloat(cpuLoadMap[c] || 0));
            if (osLoad / osCores.length > 50) {
                warnings.push(`High average OS load: ${(osLoad/osCores.length).toFixed(0)}%`);
            }
            info.push(`OS cores: ${osCores.length}, avg load: ${(osLoad/osCores.length).toFixed(0)}%`);
        }
    }
    
    let html = '';
    if (errors.length === 0 && warnings.length === 0) {
        html = '<div class="val-ok">‚úì Configuration valid</div>';
    }
    if (errors.length > 0) {
        html += '<div class="val-error" style="font-weight:bold;">Errors:</div>';
        errors.forEach(e => html += `<div class="val-error">‚Ä¢ ${e}</div>`);
    }
    if (warnings.length > 0) {
        html += '<div class="val-warn" style="font-weight:bold;margin-top:4px;">Warnings:</div>';
        warnings.forEach(w => html += `<div class="val-warn">‚Ä¢ ${w}</div>`);
    }
    if (info.length > 0) {
        html += '<div class="val-info" style="font-weight:bold;margin-top:4px;">Info:</div>';
        info.forEach(i => html += `<div class="val-info">‚Ä¢ ${i}</div>`);
    }
    
    document.getElementById('validation-output').innerHTML = html;
}

// ==================== COMPARE MODE ====================
function loadCompareFile(target) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
        const file = e.target.files[0];
        if (file) readCompareFile(file, target);
    };
    input.click();
}

function readCompareFile(file, target) {
    const reader = new FileReader();
    reader.onload = (e) => {
        try {
            const config = JSON.parse(e.target.result);
            if (target === 'old') {
                compareOld = config;
                renderComparePanel('old', config);
            } else {
                compareNew = config;
                renderComparePanel('new', config);
            }
            if (compareOld && compareNew) {
                calculateDiff();
            }
        } catch (err) {
            alert('Error parsing JSON: ' + err.message);
        }
    };
    reader.readAsText(file);
}

function clearCompare(target) {
    if (target === 'old') {
        compareOld = null;
        document.getElementById('compare-old-body').innerHTML = `
            <div class="compare-drop-zone" id="drop-old" onclick="loadCompareFile('old')">
                <div class="drop-icon">üìÅ</div>
                <div class="drop-text">Drop JSON or click to select<br><strong>Old configuration</strong></div>
            </div>
        `;
    } else {
        compareNew = null;
        document.getElementById('compare-new-body').innerHTML = `
            <div class="compare-drop-zone" id="drop-new" onclick="loadCompareFile('new')">
                <div class="drop-icon">üìÅ</div>
                <div class="drop-text">Drop JSON or click to select<br><strong>New configuration</strong></div>
            </div>
        `;
    }
    document.getElementById('compare-summary').style.display = 'none';
    initDragDrop();
}

function renderComparePanel(target, config) {
    const body = document.getElementById(`compare-${target}-body`);
    
    const geom = config.geometry || {};
    const netNumas = new Set(config.netNumaNodes || []);
    const insts = config.instances || {};
    
    let html = `<div style="margin-bottom:10px;font-size:11px;color:#888;">
        Server: <strong>${config.serverName || 'Unknown'}</strong> | 
        Date: ${config.timestamp ? new Date(config.timestamp).toLocaleString() : 'N/A'}
    </div>`;
    
    html += '<div class="blueprint" style="transform:scale(0.9);transform-origin:top left;">';
    
    const sockets = Object.keys(geom).sort((a, b) => a - b);
    sockets.forEach(socketId => {
        html += `<div class="socket" data-socket="${socketId}" style="min-width:auto;">`;
        html += `<div class="socket-label">S${socketId}</div>`;
        html += '<div class="socket-content">';
        
        Object.keys(geom[socketId]).sort((a, b) => a - b).forEach(numaId => {
            const isNetwork = netNumas.has(numaId);
            html += `<div class="numa ${isNetwork ? 'is-network' : ''}" style="min-width:auto;padding:6px;">`;
            html += `<div class="numa-label">N${numaId}</div>`;
            
            Object.keys(geom[socketId][numaId]).sort((a, b) => parseInt(a) - parseInt(b)).forEach(l3Id => {
                html += '<div class="cores-grid" style="margin-top:12px;">';
                
                geom[socketId][numaId][l3Id].forEach(cpu => {
                    const tags = insts['Physical']?.[cpu] || [];
                    let bg = '#151520';
                    let border = '#333';
                    
                    if (tags.length > 0) {
                        const role = ROLES_BY_ID[tags[0]];
                        if (role) {
                            bg = role.color;
                            border = role.color;
                        }
                    }
                    
                    html += `<div class="core compare-core" data-cpu="${cpu}" data-target="${target}"
                                 style="background:${bg};border-color:${border};${tags.length > 0 ? 'color:#fff;' : ''}">${cpu}</div>`;
                });
                
                html += '</div>';
            });
            
            html += '</div>';
        });
        
        html += '</div></div>';
    });
    
    html += '</div>';
    body.innerHTML = html;
}

function calculateDiff() {
    if (!compareOld || !compareNew) return;
    
    const oldInst = compareOld.instances?.['Physical'] || {};
    const newInst = compareNew.instances?.['Physical'] || {};
    
    const allCpus = new Set([...Object.keys(oldInst), ...Object.keys(newInst)]);
    
    let added = 0, removed = 0, changed = 0;
    
    allCpus.forEach(cpu => {
        const oldTags = new Set(oldInst[cpu] || []);
        const newTags = new Set(newInst[cpu] || []);
        
        const hadRole = oldTags.size > 0;
        const hasRole = newTags.size > 0;
        
        const oldEl = document.querySelector(`.compare-core[data-cpu="${cpu}"][data-target="old"]`);
        const newEl = document.querySelector(`.compare-core[data-cpu="${cpu}"][data-target="new"]`);
        
        if (!hadRole && hasRole) {
            added++;
            if (newEl) newEl.classList.add('diff-added');
        } else if (hadRole && !hasRole) {
            removed++;
            if (oldEl) oldEl.classList.add('diff-removed');
        } else if (hadRole && hasRole) {
            const same = oldTags.size === newTags.size && [...oldTags].every(t => newTags.has(t));
            if (!same) {
                changed++;
                if (oldEl) oldEl.classList.add('diff-changed');
                if (newEl) newEl.classList.add('diff-changed');
            }
        }
    });
    
    document.getElementById('diff-added').textContent = added;
    document.getElementById('diff-removed').textContent = removed;
    document.getElementById('diff-changed').textContent = changed;
    document.getElementById('compare-summary').style.display = 'flex';
}
</script>
</body>
</html>
